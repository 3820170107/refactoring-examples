replace-subclass-with-fields:java

###

1.ru. Примените к подклассам <a href="/replace-constructor-with-factory-method">замену конструктора фабричным методом</a>.
1.uk. Застосуйте до підкласів <a href="/replace-constructor-with-factory-method">заміну конструктора фабричним методом</a>.

2.ru. Замените вызовы конструкторов подклассов вызовами фабричного метода суперкласса.
2.uk. Якщо якийсь код посилається на підкласи, заміните його використанням суперкласу.

3.ru. Объявите в суперклассе поля для хранения значений каждого из методов подклассов, возвращающих константные значения.
3.uk. Оголосіть в суперкласі поля для зберігання значень кожного з методів підкласів, що повертають константні значення.

4.ru. Создайте защищённый конструктор суперкласса для инициализации новых полей.
4.uk. Створіть захищений конструктор суперкласу для ініціалізації нових полів.

5.ru. Создайте или модифицируйте имеющиеся конструкторы подклассов, чтобы они вызывали новый конструктор суперкласса.
5.uk. Створіть або змінюйте наявні конструктори підкласів, щоб вони викликали новий конструктор суперкласу.

6.ru. Реализуйте каждый константный метод в родительском классе так, чтобы он возвращал значение соответствующего поля, а затем удалите метод из подкласса.
6.uk. Реалізуйте кожен константний метод у батьківському класі так, щоб він повертав значення відповідного поля, а потім видалите метод з підкласу.

7.ru. Если конструктор подкласса имеет какую-то дополнительную функциональность,  примените <a href="/inline-method">встраивание метода</a> для встраивания его конструктора в фабричный метод суперкласса.
7.uk. Якщо конструктор підкласу має якусь додаткову функціональність, застосуйте <a href="/inline-method">вбудовування методу</a> для вбудовування конструктора у фабричний метод суперкласу.

8.ru. Удалите подкласс.
8.uk. Видаліть підклас.



###

```
abstract class Person {
  abstract boolean isMale();
  abstract char getCode();
}

class Male extends Person {
  boolean isMale() {
    return true;
  }
  char getCode() {
    return 'M';
  }
}
class Female extends Person {
  boolean isMale() {
    return false;
  }
  char getCode() {
    return 'F';
  }
}

// Клиентский код
Person kent = new Male();
System.out.print("Person's gender is: " + kent.getCode());
```

###

```
class Person {
  static Person createMale() {
    return new Person(true, 'M');
  }
  static Person createFemale() {
    return new Person(false, 'F');
  }
  protected Person(boolean isMale, char code) {
    this.isMale = isMale;
    this.code = code;
  }

  private final boolean isMale;
  private final char code;

  boolean isMale() {
    return isMale;
  }
  boolean getCode() {
    return code;
  }
}


// Клиентский код
Person kent = Person.createMale();
System.out.print("Person's gender is: " + kent.getCode());
```

###

Set step 1

#|ru| Рассмотрим рефакторинг <i>Замена подкласса полями</i> на примере всё того же класса человека и его подклассов, выделенных по признаку пола.
#|uk| Розглянемо рефакторинг <i>Заміна підкласу полями<i> на прикладі все того ж класу людини та її підкласів, виділених за ознакою статі.

Select "return true"
+ Select "return false"
+ Select "return 'M'"
+ Select "return 'F'"

#|ru| Единственное различие между подклассами здесь в том, что в них есть реализации абстрактного метода, возвращающие жёстко закодированные константы. От таких классов лучше избавиться.
#|uk| Єдина відмінність між підклассами в данному втпадкому в тому, що в них є реалізації абстрактного методу, що повертають жорстко закодовані константи. Від таких класів краще позбутися.

Go to the beginning of "Person"

#|ru| Сначала следует применить <a href="/replace-constructor-with-factory-method">Замену конструктора фабричным методом</a>. В данном случае нам нужен фабричный метод для каждого подкласса.
#|uk| Спочатку слід застосувати <a href="/replace-constructor-with-factory-method">Заміну конструктора фабричним методом</a>. В даному випадку нам потрібен фабричний метод для кожного підкласу.

Print:
```

  static Person createMale() {
    return new Male();
  }
  static Person createFemale() {
    return new Female();
  }
```

Set step 2

Select "Person kent = |||new Male()|||"

#|ru| После этого следует заменить все вызовы конструкторов подклассов вызовами соответствующих фабричных методов.
#|uk| Після цього слід замінити всі виклики конструкторів підкласів викликами відповідних фабричних методів.

Print "Person.createMale()"

#|ru| После замены всех этих вызовов в коде не должно остаться упоминаний подклассов.
#|uk| Після заміни всіх цих викликів в коді не повинно залишитися згадок про підкласи.

Set step 3

Go to after "createFemale"

#|ru| Теперь в родительском классе объявим поля для каждого метода, возвращавшего константы в подклассах.
#|uk| Тепер в батьківському класі оголосимо поля для кожного методу, який повертає константи в підкласах.

Print:
```


  private final boolean isMale;
  private final char code;

```

Set step 4

Go to after "createFemale"

#|ru| Добавляем в родительский класс защищённый конструктор.
#|uk| Додаємо в батьківський клас захищений конструктор.

Print:
```

  protected Person(boolean isMale, char code) {
    this.isMale = isMale;
    this.code = code;
  }
```

Set step 5

Go to the start of "Male"

#|ru| Добавляем конструкторы, вызывающие этот новый конструктор в подклассах.
#|uk| Додаємо конструктори, які викликають цей новий конструктор в підкласах.

Print:
```

  Male() {
    super(true, 'M');
  }
```

Go to the start of "Female"

Print:
```

  Female() {
    super(false, 'F');
  }
```

#C|ru| После этого можно выполнить компиляцию и тестирование.
#S Всё отлично, можно продолжать.

#C|uk| Після цього можна виконати компіляцію і тестування.
#S Все добре, можна продовжувати.

Set step 6

Select "  abstract boolean isMale();"

#|ru| Поля создаются и инициализируются, но пока они не используются. Теперь мы можем ввести поля в игру, поместив в родительском классе методы доступа и удалив методы подклассов.
#|uk| Поля створюються та ініціалізуються, але поки вони не використовуються. Тепер ми можемо ввести поля в гру, помістивши в батьківському класі методи доступу і видаливши методи підкласів.

Print:
```
  boolean isMale() {
    return isMale;
  }
```

Wait 500ms

Select whole "isMale" in "Male"

Remove selected

Wait 500ms

Select whole "isMale" in "Female"

Remove selected

Select "  abstract char getCode();"

Replace:
```
  boolean getCode() {
    return code;
  }
```

Wait 500ms

Select whole "getCode" in "Male"

Remove selected

Wait 500ms

Select whole "getCode" in "Female"

Remove selected

Set step 7

Select "|||abstract||| class Person"
+ Select "new Male()"
+ Select "new Female()"

#|ru| В итоге все подклассы оказываются пустыми, поэтому мы снимаем пометку abstract с класса Person и с помощью <a href="/inine-method">Встраивания метода</a> встраиваем конструктор подкласса в родительский класс.
#|uk| У підсумку всі підкласи виявляються порожніми, тому ми знімаємо позначку abstract з класу Person і за допомогою <a href="/inine-method">вбудовування методу</a> вбудовуємо конструктор підкласу в батьківський клас.

Select "|||abstract |||class Person"

Remove selected

Wait 500ms

Select "new Male()"

Replace "new Person(true, 'M')"

Set step 8

Select whole "Male"

#|ru| После этого класс <code>Male</code> можно спокойно удалить.
#|uk| Після цього клас <code>Male</code> можна спокійно видалити.

Remove selected

#C|ru| Проведём компиляцию и тестирование, чтобы убедиться, что никакой другой код не сломался.
#S Всё хорошо, можно проделать ту же операцию с классом <code>Female</code>

#C|uk| Проведемо компіляцію і тестування, щоб переконатися, що ніякої іншої код не зламався.
#S Все добре, можна виконати ту ж операцію з класом <code>Female</code.


Select "new Female()"

Replace "new Person(false, 'F')"

Wait 500ms

Select whole "Female"

Remove selected

#C|ru| Запускаем финальную компиляцию и тестирование.
#S Отлично, все работает!

#C|uk| Запускаємо фінальну компіляцію і тестування.
#S Супер, все працює.

Set final step

#|ru|Q На этом рефакторинг можно считать оконченным. В завершение, можете посмотреть разницу между старым и новым кодом.
#|uk|Q На цьому рефакторинг можна вважати закінченим. На завершення, можете подивитися різницю між старим та новим кодом.