add-parameter:php

###

1.ru. Проверьте, не определён ли метод в суперклассе или подклассе. Если метод в них присутствует, нужно будет повторить все шаги также в этих классах.
1.uk. Перевірте, чи не є метод вже визначеним в суперкласі або підкласі. Якщо метод в них вже присутній, треба буде повторити усі кроки також в цих класах.

2.ru. Следующий шаг важен, чтобы сохранить работоспособность программы во время рефакторинга. Итак, создайте новый метод, скопировав старый, и добавьте в него требуемый параметр. Замените код старого метода вызовом нового метода. Вы можете подставить любое значение в новый параметр (например <code>null</code> для объектов или ноль для чисел).
2.uk. Наступний крок важливий для того, щоб зберегти працездатність програми під час рефакторінгу. Отже, створіть новий метод, скопіювавши старий, і додайте в нього необхідний параметр. Замініть код старого методу викликом нового методу. Ви можете підставити будь-яке значення в новий параметр (наприклад <code>null</code> для об'єктів або нуль для чисел).

3.ru. Найдите все обращения к старому методу и замените их обращениями к новому методу.
3.uk. Знайдіть усі звернення до старого методу і замініть їх зверненнями до нового методу.

4.ru. Удалите старый метод. Этот шаг неосуществим, если старый метод является частью публичного интерфейса. В этом случае старый метод нужно пометить как устаревший (<code>deprecated</code>).
4.uk. Видаліть старий метод. Цей крок стає неможливим, якщо старий метод є частиною публічного інтерфейсу. В цьому випадку старий метод треба помітити як застарілий (<code>deprecated</code>).



###

```
class Calendar {
  // ...
  private $appointments; // array
  public function findAppointment(DateTime $date) {
    $result = array();
    foreach ($this->appointments as $each) {
      if ($date->format('Y-m-d') == $each->date->format('Y-m-d')) {
        $result[] = $date;
      }
    }
    return $result;
  }
}

// Somewhere in client code
$today = new DateTime();
$appointments = $calendar->findAppointment($today);
```

###

```
class Calendar {
  // ...
  private $appointments; // array
  public function findAppointmentByDateAndName(DateTime $date, $name) {
    $result = array();
    foreach ($this->appointments as $each) {
      if ($date->format('Y-m-d') == $each->date->format('Y-m-d')) {
        if ($name == null || ($name != null && $name == $each->name)) {
          $result[] = $date;
        }
      }
    }
    return $result;
  }
}

// Somewhere in client code
$today = new DateTime();
$appointments = $calendar->findAppointmentByDateAndName($today, null);
```

###

Set step 1

#|ru| У нас есть класс Календарь, в котором хранятся записи о запланированных встречах.
#|uk| Ми маємо клас Календар, в якому зберігаються записи щодо запланованих зустрічей.

Select name of "findAppointment"

#|ru| В нём есть метод, который возвращает значения встреч на определенную дату.
#|uk| У ньому є метод, який повертає значення зустрічей на певну дату.

#|ru| Было бы неплохо, если бы этот метод мог фильтровать посетителей ещё и по имени.
#|uk| Було б непогано, якби цей метод міг фільтрувати відвідувачів ще й за ім'ям.

Set step 2

#|ru| Можно просто вписать новый параметр в описание метода, но в таком случае есть большая вероятность «сломать» вызовы этого метода в других фрагментах кода.
#|uk| Можна просто вписати новий параметр в опис методу, але в такому випадку є велика ймовірність «зламати» виклики цього методу в інших фрагментах коду.

Go to the end of "Calendar"

#|ru| Поэтому мы будем продвигаться очень осторожно и создадим новый метод с желаемым параметром, для начала скопировав туда тело существующего.
#|uk| Тому ми будемо просуватися дуже обережно і створимо новий метод з бажаним параметром, для початку скопіювавши туди тіло існуючого.

#|ru| Так как в PHP отсутствует механизм перегрузки (overload) функций, мы даём методу новое имя.
#|uk| Так як в PHP відсутній механізм перевантаження (overload) функцій, ми даємо методу нове ім'я.

Print:
```

  public function findAppointmentByDateAndName(DateTime $date, $name) {
    $result = array();
    foreach ($this->appointments as $each) {
      if ($date->format('Y-m-d') == $each->date->format('Y-m-d')) {
        $result[] = $date;
      }
    }
    return $result;
  }
```

Select 2nd "        $result[] = $date;"

#|ru| Тело метода изменяем под использование нового метода.
#|uk| Тіло методу змінюємо під використання нового методу.

Print:
```
        if ($name == null || ($name != null && $name == $each->name)) {
          $result[] = $date;
        }
```

Select body of "findAppointment"

#|ru| Теперь тело старого метода можно заменить вызовом нового метода.
#|uk| Тепер тіло старого методу можна замінити викликом нового методу.

Print:
```
    findAppointmentByDateAndName($date, null);
```

Set step 3

Select name of "findAppointment"

#|ru| Далее нужно найти все обращения к старому методу и заменить их обращениями к новому.
#|uk| Далі потрібно знайти всі звернення до старого методу і замінити їх зверненнями до нового.

Select "$calendar->findAppointment($today);"

#|ru| Вот одно из них. Так как нам нечего подать в новый параметр, впишем значение <code>null</code>.
#|uk| Ось одне з них. Так як нам нема чого подавати в новий параметр, використаємо значення <code>null</code>.

Select "$calendar->|||findAppointment|||($today);"

Replace "findAppointmentByDateAndName"

Go to "$calendar->findAppointmentByDateAndName($today|||);"

Print ", null"

Set step 4

Select whole "findAppointment"

#|ru| После проведения всех изменений старый метод можно удалить.
#|uk| Після проведення всіх змін старий метод можна видалити.

Remove selected

#C|ru| Запускаем финальное тестирование.
#S Отлично, все работает!

#C|uk| Запускаємо фінальне тестування.
#S Супер, все працює.

Set final step

#|ru|Q На этом рефакторинг можно считать оконченным. В завершение, можете посмотреть разницу между старым и новым кодом.
#|uk|Q На цьому рефакторинг можна вважати закінченим. На завершення, можете подивитися різницю між старим та новим кодом.