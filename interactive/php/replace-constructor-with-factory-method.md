replace-constructor-with-factory-method:php

###

1.ru. Создайте фабричный метод. Поместите в его тело вызова текущего конструктора.
1.uk. Створіть фабричний метод. Помістіть його в тіло виклику поточного конструктора.

2.ru. Замените все вызовы конструктора вызовами фабричного метода.
2.uk. Замініть усі виклики конструктора викликами фабричного методу.

3.ru. Объявите конструктор приватным.
3.uk. Оголосіть конструктор приватним.

4.ru. Обследуйте код конструктора и попытайтесь вынести в фабричный метод тот код, который не относится к непосредственному конструированию объекта текущего класса.
4.uk. Обстежте код конструктора і спробуйте винести у фабричний метод той код, який не відноситься до безпосереднього конструювання об'єкту поточного класу.



###

```
class Employee {
  // ...
  const ENGINEER = 0;
  const SALESMAN = 1;
  const MANAGER = 2;

  public function __construct($type) {
    $this->type = $type;
  }
}

// Some clinet code.
$eng = new Employee(Employee::ENGINEER);
```

###

```
class Employee {
  // ...
  const ENGINEER = 0;
  const SALESMAN = 1;
  const MANAGER = 2;

  public static function create($type) {
    switch ($type) {
      case self::ENGINEER:
        return new Engineer();
      case self::SALESMAN:
        return new Salesman();
      case self::MANAGER:
        return new Manger();
      default:
        return new Employee($type);
    }
  }
  private function __construct($type) {
    $this->type = $type;
  }
}
class Engineer extends Employee {
  // ...
}
class Salesman extends Employee {
  // ...
}
class Manager extends Employee {
  // ...
}

// Some clinet code.
$eng = Employee::create(Employee::ENGINEER);
```

###

Set step 1

#|ru| Допустим, у нас есть класс для создания сотрудников,…
#|uk| Припустимо, у нас є клас для створення співробітників,...

Select parameters in "__construct"

#|ru|< ...в котором тип сотрудника задаётся параметром конструктора.
#|uk|< ...в якому тип співробітника задається параметром конструктора.

Select "new Employee"

#|ru| Клиентский код вызывает этот конструктор напрямую.
#|uk| Клієнтський код викликає цей конструктор безпосередньо.

#|ru| Предположим, мы захотели создать подклассы для каждого типа сотрудников.
#|uk| Припустимо, ми захотіли створити підкласи для кожного типу співробітників.

Go to after "Employee"

Print:
```

class Engineer extends Employee {
  // ...
}
class Salesman extends Employee {
  // ...
}
class Manager extends Employee {
  // ...
}
```

Select "new Employee"

#|ru| Что случилось бы с этим кодом? Его пришлось бы переписать, т.к. мы не можем возвращать ничего другого из конструктора <code>Employee</code>, кроме объектов <code>Employee</code> (а нам нужен <code>Engineer</code>).
#|uk| Що сталося б з цим кодом? Його довелося б переписати, так як ми не можемо повертати нічого іншого з конструктора <code>Employee</code>, крім об'єктів <code>Employee</code> (а нам потрібен <code>Engineer</code>).

#|ru| Но если потом что-то снова поменяется, нам придется создавать ещё больше подклассов, и, вполне возможно, что вызовы конструкторов снова придётся править.
#|uk| Але якщо потім щось знову поміняється, нам доведеться створювати ще більше підкласів, і, цілком можливо, що виклики конструкторів знову доведеться правити.

#|ru| Альтернативой этому является создание <b>фабричного метода</b> – специального статического метода, который бы возвращал объекты разных классов в зависимости от параметров.
#|uk| Альтернативою цьому є створення <b> фабричного методу </ b> – спеціального статичного методу, який би повертав об'єкти різних класів в залежності від параметрів.

Go to before "__construct"

#|ru| Класс <code>Employee</code> является лучшим местом для хранения фабричного метода, так как он, скорее всего, переживёт любые изменения подклассов.
#|uk| Клас <code>Employee</code> є кращим місцем для зберігання фабричного методу, так як він, швидше за все, переживе будь-які зміни підкласів.

Print:
```

  public static function create($type) {
    return new Employee($type);
  }
```

#|ru| На данном этапе фабричный метод будет вызывать текущий конструктор, но мы изменим это в ближайшем будущем.
#|uk| На даному етапі фабричний метод викликатиме поточний конструктор, але ми змінимо це в найближчому майбутньому.

Set step 2

Select "new Employee"

#|ru| Теперь нужно найти все прямые вызовы конструкторов и заменить их вызовами фабричного метода.
#|uk| Тепер потрібно знайти всі прямі виклики конструкторів і замінити їх викликами фабричного методу.

Print "Employee::create"

Set step 3

Select visibility of "__construct"

#|ru| После всех замен конструктор можно скрыть от посторонних глаз, сделав его приватным.
#|uk| Після всіх замін конструктор можна приховати від сторонніх очей, зробивши його приватним.

Print "private"

Set step 4

Select body of "create"

#|ru| После этого можно создать в фабричном методе условный оператор, который будет возвращать объект нужного класса в зависимости от параметра.
#|uk| Після цього можна створити у фабричному методі умовний оператор, який буде повертати об'єкт потрібного класу залежно від параметра.

Print:
```
    switch ($type) {
      case self::ENGINEER:
        return new Engineer();
      case self::SALESMAN:
        return new Salesman();
      case self::MANAGER:
        return new Manger();
      default:
        return new Employee($type);
    }
```

#C|ru| Запускаем финальное тестирование.
#S Отлично, все работает!

#C|uk| Запускаємо фінальне тестування.
#S Супер, все працює.

Set final step

#|ru|Q На этом рефакторинг можно считать оконченным. В завершение, можете посмотреть разницу между старым и новым кодом.
#|uk|Q На цьому рефакторинг можна вважати закінченим. На завершення, можете подивитися різницю між старим та новим кодом.